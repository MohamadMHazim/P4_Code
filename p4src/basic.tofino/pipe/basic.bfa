version:
  run_id: "d3f78321a2a14e1e"
  target: Tofino
error_mode: propagate_and_disable
phv ingress:
  ig_intr_md.ingress_port: {  stage 0..1: H3(0..8) } 
  hdr.ethernet.dst_addr.0-15: TH2
  hdr.ethernet.dst_addr.16-31: TH3
  hdr.ethernet.dst_addr.32-47: TH14
  hdr.ethernet.src_addr.0-31: TW3
  hdr.ethernet.src_addr.32-47: TH13
  hdr.ethernet.ether_type: TH12
  hdr.ipv4.version: TH0(12..15)
  hdr.ipv4.ihl: TH0(8..11)
  hdr.ipv4.diffserv: TH0(0..7)
  hdr.ipv4.total_len: H0
  hdr.ipv4.identification: TW1(16..31)
  hdr.ipv4.flags: TW1(13..15)
  hdr.ipv4.frag_offset: TW1(0..12)
  hdr.ipv4.ttl: TB0
  hdr.ipv4.protocol: B2
  hdr.ipv4.hdr_checksum: TH1
  hdr.ipv4.src_addr: W2
  hdr.ipv4.dst_addr: W1
  hdr.tcp.sport: W0(16..31)
  hdr.tcp.dport: W0(0..15)
  hdr.tcp.seq: TW8
  hdr.tcp.ack.0-15: TH4
  hdr.tcp.ack.16-31: TH5
  hdr.tcp.dataofs: TW0(28..31)
  hdr.tcp.reserved: TW0(24..27)
  hdr.tcp.flags: TW0(16..23)
  hdr.tcp.window: TW0(0..15)
  hdr.tcp.chksum: TW2(16..31)
  hdr.tcp.urgptr: TW2(0..15)
  hdr.udp.sport: TW2(16..31)
  hdr.udp.dport: TW2(0..15)
  hdr.udp.len: TW0(16..31)
  hdr.udp.chksum: TW0(0..15)
  meta.is_tcp: {  stage 1..2: B1(4) } 
  meta.is_https: {  stage 1: B3(4) } 
  meta.flow_idx: {  stage 1..2: H4 } 
  meta.pkt_len: {  stage 1..2: H1 } 
  ig_intr_md_for_tm.ucast_egress_port: {  stage 2..12: H2(0..8) } 
  ig_intr_md_for_tm.bypass_egress: {  stage 2..12: B1(3) } 
  ig_intr_md_for_dprsr.drop_ctl: {  stage 2..12: B1(0..2) } 
  ig_intr_md_for_dprsr.mirror_type: {  stage 12: B0(0..2) } 
  $tmp2: {  stage 12: H3(0..9) } 
  hdr.ethernet.$valid: B3(0)
  hdr.ipv4.$valid: B3(1)
  hdr.tcp.$valid: B3(2)
  hdr.udp.$valid: B3(3)
phv egress:
  eg_intr_md.egress_port: H16(0..8)
  eg_intr_md.pkt_length: {  stage 0: H17 } 
  hdr.min_parse_depth_padding_0$0.packet_payload.0-31: TW4
  hdr.min_parse_depth_padding_0$0.packet_payload.32-63: TW5
  hdr.min_parse_depth_padding_0$0.packet_payload.64-79: TH18
  hdr.min_parse_depth_padding_0$0.packet_payload.80-87: TB4
  hdr.min_parse_depth_padding_0$1.packet_payload.0-31: TW6
  hdr.min_parse_depth_padding_0$1.packet_payload.32-63: TW7
  hdr.min_parse_depth_padding_0$1.packet_payload.64-79: TH19
  hdr.min_parse_depth_padding_0$1.packet_payload.80-87: TB5
  hdr.min_parse_depth_padding_0$2.packet_payload.0-15: TH6
  hdr.min_parse_depth_padding_0$2.packet_payload.16-31: TH7
  hdr.min_parse_depth_padding_0$2.packet_payload.32-47: TH8
  hdr.min_parse_depth_padding_0$2.packet_payload.48-63: TH9
  hdr.min_parse_depth_padding_0$2.packet_payload.64-79: TH20
  hdr.min_parse_depth_padding_0$2.packet_payload.80-87: TB6
  hdr.min_parse_depth_padding_0$3.packet_payload.0-15: TH10
  hdr.min_parse_depth_padding_0$3.packet_payload.16-31: TH11
  hdr.min_parse_depth_padding_0$3.packet_payload.32-63: TW12
  hdr.min_parse_depth_padding_0$3.packet_payload.64-79: TH21
  hdr.min_parse_depth_padding_0$3.packet_payload.80-87: TB7
  hdr.min_parse_depth_padding_0.$stkvalid: B16(0..3)
  hdr.min_parse_depth_padding_0$0.$valid: {  stage 12: B16(3) } 
  hdr.min_parse_depth_padding_0$1.$valid: {  stage 12: B16(2) } 
  hdr.min_parse_depth_padding_0$2.$valid: {  stage 12: B16(1) } 
  hdr.min_parse_depth_padding_0$3.$valid: B16(0)
parser ingress:
  start: $entry_point.start
  init_zero: [ B1, B3, H4, H1, B0 ]
  bitwise_or: [ B3 ]
  hdr_len_adj: 16
  states:
    $entry_point.start:
      *:
        0..1: H3  # bit[7..15] -> H3 bit[8..0]: ingress::ig_intr_md.ingress_port
        16..17: TH14  # ingress::hdr.ethernet.dst_addr[47:32].32-47
        18..19: TH3  # ingress::hdr.ethernet.dst_addr[31:16].16-31
        20..21: TH2  # ingress::hdr.ethernet.dst_addr[15:0].0-15
        24..27: TW3  # ingress::hdr.ethernet.src_addr[31:0].0-31
        B3: 1  # value 1 -> B3 bit[0]: ingress::hdr.ethernet.$valid
        load: { half : 28..29 }
        shift: 22
        buf_req: 30
        next: $entry_point.start.$split_0
    $entry_point.start.$split_0:
      match: [ half ]
      0x0800:
        0..1: TH13  # ingress::hdr.ethernet.src_addr[47:32].32-47
        6..7: TH12  # ingress::hdr.ethernet.ether_type
        load: { byte1 : 17 }
        shift: 8
        buf_req: 18
        next: parse_ipv4
      0x****:
        0..1: TH13  # ingress::hdr.ethernet.src_addr[47:32].32-47
        6..7: TH12  # ingress::hdr.ethernet.ether_type
        shift: 8
        buf_req: 8
        next: end
    parse_ipv4:
      match: [ byte1 ]
      0x06:
        0..1: TH0
            # - bit[0..3] -> TH0 bit[15..12]: ingress::hdr.ipv4.version
            # - bit[4..7] -> TH0 bit[11..8]: ingress::hdr.ipv4.ihl
            # - bit[8..15] -> TH0 bit[7..0]: ingress::hdr.ipv4.diffserv
        2..3: H0  # ingress::hdr.ipv4.total_len
        4..7: TW1
            # - bit[32..47] -> TW1 bit[31..16]: ingress::hdr.ipv4.identification
            # - bit[48..50] -> TW1 bit[15..13]: ingress::hdr.ipv4.flags
            # - bit[51..63] -> TW1 bit[12..0]: ingress::hdr.ipv4.frag_offset
        8: TB0  # ingress::hdr.ipv4.ttl
        9: B2  # ingress::hdr.ipv4.protocol
        10..11: TH1  # ingress::hdr.ipv4.hdr_checksum
        12..15: W2  # ingress::hdr.ipv4.src_addr
        16..19: W1  # ingress::hdr.ipv4.dst_addr
        B3: 2  # value 1 -> B3 bit[1]: ingress::hdr.ipv4.$valid
        shift: 20
        buf_req: 20
        next: parse_tcp
      0x11:
        0..1: TH0
            # - bit[0..3] -> TH0 bit[15..12]: ingress::hdr.ipv4.version
            # - bit[4..7] -> TH0 bit[11..8]: ingress::hdr.ipv4.ihl
            # - bit[8..15] -> TH0 bit[7..0]: ingress::hdr.ipv4.diffserv
        2..3: H0  # ingress::hdr.ipv4.total_len
        4..7: TW1
            # - bit[32..47] -> TW1 bit[31..16]: ingress::hdr.ipv4.identification
            # - bit[48..50] -> TW1 bit[15..13]: ingress::hdr.ipv4.flags
            # - bit[51..63] -> TW1 bit[12..0]: ingress::hdr.ipv4.frag_offset
        8: TB0  # ingress::hdr.ipv4.ttl
        9: B2  # ingress::hdr.ipv4.protocol
        10..11: TH1  # ingress::hdr.ipv4.hdr_checksum
        12..15: W2  # ingress::hdr.ipv4.src_addr
        16..19: W1  # ingress::hdr.ipv4.dst_addr
        B3: 2  # value 1 -> B3 bit[1]: ingress::hdr.ipv4.$valid
        shift: 20
        buf_req: 20
        next: parse_udp
      0x**:
        0..1: TH0
            # - bit[0..3] -> TH0 bit[15..12]: ingress::hdr.ipv4.version
            # - bit[4..7] -> TH0 bit[11..8]: ingress::hdr.ipv4.ihl
            # - bit[8..15] -> TH0 bit[7..0]: ingress::hdr.ipv4.diffserv
        2..3: H0  # ingress::hdr.ipv4.total_len
        4..7: TW1
            # - bit[32..47] -> TW1 bit[31..16]: ingress::hdr.ipv4.identification
            # - bit[48..50] -> TW1 bit[15..13]: ingress::hdr.ipv4.flags
            # - bit[51..63] -> TW1 bit[12..0]: ingress::hdr.ipv4.frag_offset
        8: TB0  # ingress::hdr.ipv4.ttl
        9: B2  # ingress::hdr.ipv4.protocol
        10..11: TH1  # ingress::hdr.ipv4.hdr_checksum
        12..15: W2  # ingress::hdr.ipv4.src_addr
        16..19: W1  # ingress::hdr.ipv4.dst_addr
        B3: 2  # value 1 -> B3 bit[1]: ingress::hdr.ipv4.$valid
        shift: 20
        buf_req: 20
        next: end
    parse_tcp:
      *:
        0..3: W0
            # - bit[0..15] -> W0 bit[31..16]: ingress::hdr.tcp.sport
            # - bit[16..31] -> W0 bit[15..0]: ingress::hdr.tcp.dport
        4..7: TW8  # ingress::hdr.tcp.seq
        8..9: TH5  # ingress::hdr.tcp.ack[31:16].16-31
        10..11: TH4  # ingress::hdr.tcp.ack[15:0].0-15
        12..15: TW0
            # - bit[96..99] -> TW0 bit[31..28]: ingress::hdr.tcp.dataofs
            # - bit[100..103] -> TW0 bit[27..24]: ingress::hdr.tcp.reserved
            # - bit[104..111] -> TW0 bit[23..16]: ingress::hdr.tcp.flags
            # - bit[112..127] -> TW0 bit[15..0]: ingress::hdr.tcp.window
        16..19: TW2
            # - bit[128..143] -> TW2 bit[31..16]: ingress::hdr.tcp.chksum
            # - bit[144..159] -> TW2 bit[15..0]: ingress::hdr.tcp.urgptr
        B3: 4  # value 1 -> B3 bit[2]: ingress::hdr.tcp.$valid
        shift: 20
        buf_req: 20
        next: end
    parse_udp:
      *:
        0..3: TW2
            # - bit[0..15] -> TW2 bit[31..16]: ingress::hdr.udp.sport
            # - bit[16..31] -> TW2 bit[15..0]: ingress::hdr.udp.dport
        4..7: TW0
            # - bit[32..47] -> TW0 bit[31..16]: ingress::hdr.udp.len
            # - bit[48..63] -> TW0 bit[15..0]: ingress::hdr.udp.chksum
        B3: 8  # value 1 -> B3 bit[3]: ingress::hdr.udp.$valid
        shift: 8
        buf_req: 8
        next: end
deparser ingress:
  dictionary:
    TH14: B3(0)  # ingress::hdr.ethernet.dst_addr.32-47 if ingress::hdr.ethernet.$valid
    TH3: B3(0)  # ingress::hdr.ethernet.dst_addr.16-31 if ingress::hdr.ethernet.$valid
    TH2: B3(0)  # ingress::hdr.ethernet.dst_addr.0-15 if ingress::hdr.ethernet.$valid
    TH13: B3(0)  # ingress::hdr.ethernet.src_addr.32-47 if ingress::hdr.ethernet.$valid
    TW3: B3(0)  # ingress::hdr.ethernet.src_addr.0-31 if ingress::hdr.ethernet.$valid
    TH12: B3(0)  # ingress::hdr.ethernet.ether_type if ingress::hdr.ethernet.$valid
    TH0: B3(1)
        # - bit[15..12]: ingress::hdr.ipv4.version if ingress::hdr.ipv4.$valid
        # - bit[11..8]: ingress::hdr.ipv4.ihl if ingress::hdr.ipv4.$valid
        # - bit[7..0]: ingress::hdr.ipv4.diffserv if ingress::hdr.ipv4.$valid
    H0: B3(1)  # ingress::hdr.ipv4.total_len if ingress::hdr.ipv4.$valid
    TW1: B3(1)
        # - bit[31..16]: ingress::hdr.ipv4.identification if ingress::hdr.ipv4.$valid
        # - bit[15..13]: ingress::hdr.ipv4.flags if ingress::hdr.ipv4.$valid
        # - bit[12..0]: ingress::hdr.ipv4.frag_offset if ingress::hdr.ipv4.$valid
    TB0: B3(1)  # ingress::hdr.ipv4.ttl if ingress::hdr.ipv4.$valid
    B2: B3(1)  # ingress::hdr.ipv4.protocol if ingress::hdr.ipv4.$valid
    TH1: B3(1)  # ingress::hdr.ipv4.hdr_checksum if ingress::hdr.ipv4.$valid
    W2: B3(1)  # ingress::hdr.ipv4.src_addr if ingress::hdr.ipv4.$valid
    W1: B3(1)  # ingress::hdr.ipv4.dst_addr if ingress::hdr.ipv4.$valid
    W0: B3(2)
        # - bit[31..16]: ingress::hdr.tcp.sport if ingress::hdr.tcp.$valid
        # - bit[15..0]: ingress::hdr.tcp.dport if ingress::hdr.tcp.$valid
    TW8: B3(2)  # ingress::hdr.tcp.seq if ingress::hdr.tcp.$valid
    TH5: B3(2)  # ingress::hdr.tcp.ack.16-31 if ingress::hdr.tcp.$valid
    TH4: B3(2)  # ingress::hdr.tcp.ack.0-15 if ingress::hdr.tcp.$valid
    TW0: B3(2)
        # - bit[31..28]: ingress::hdr.tcp.dataofs if ingress::hdr.tcp.$valid
        # - bit[27..24]: ingress::hdr.tcp.reserved if ingress::hdr.tcp.$valid
        # - bit[23..16]: ingress::hdr.tcp.flags if ingress::hdr.tcp.$valid
        # - bit[15..0]: ingress::hdr.tcp.window if ingress::hdr.tcp.$valid
    TW2: B3(2)
        # - bit[31..16]: ingress::hdr.tcp.chksum if ingress::hdr.tcp.$valid
        # - bit[15..0]: ingress::hdr.tcp.urgptr if ingress::hdr.tcp.$valid
    TW2: B3(3)
        # - bit[31..16]: ingress::hdr.udp.sport if ingress::hdr.udp.$valid
        # - bit[15..0]: ingress::hdr.udp.dport if ingress::hdr.udp.$valid
    TW0: B3(3)
        # - bit[31..16]: ingress::hdr.udp.len if ingress::hdr.udp.$valid
        # - bit[15..0]: ingress::hdr.udp.chksum if ingress::hdr.udp.$valid
  egress_unicast_port: H2(0..8)  # bit[8..0]: ingress::ig_intr_md_for_tm.ucast_egress_port
  bypss_egr: B1(3..3)  # bit[3]: ingress::ig_intr_md_for_tm.bypass_egress
  drop_ctl: B1(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.drop_ctl
  mirror:
    select: B0(0..2)  # bit[2..0]: ingress::ig_intr_md_for_dprsr.mirror_type
    0:
      - H3(0..9)  # bit[9..0]: ingress::$tmp2
parser egress:
  start: $entry_point.start.min_parse_depth_accept_initial
  init_zero: [ B16 ]
  bitwise_or: [ B16 ]
  hdr_len_adj: 27
  meta_opt: 8191
  states:
    $entry_point.start.min_parse_depth_accept_initial:
      *:
        counter:
          imm: 38
        0..1: H16  # bit[7..15] -> H16 bit[8..0]: egress::eg_intr_md.egress_port
        25..26: H17  # egress::eg_intr_md.pkt_length
        intr_md: 25
        shift: 27
        buf_req: 27
        next: $entry_point.start.min_parse_depth_accept_initial.$ctr_stall0
    $entry_point.start.min_parse_depth_accept_initial.$ctr_stall0:
      *:
        buf_req: 0
        next: $entry_point.start.min_parse_depth_accept_initial.$split_0
    $entry_point.start.min_parse_depth_accept_initial.$split_0:
      match: [ ctr_neg, ctr_zero ]
      0x0:
        counter: dec 11
        0: TB4  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[87:80].80-87
        1..2: TH18  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[79:64].64-79
        3..6: TW5  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[63:32].32-63
        7..10: TW4  # egress::hdr.min_parse_depth_padding_0[0].packet_payload[31:0].0-31
        B16: 8  # value 8 -> B16 bit[3..0]: egress::hdr.min_parse_depth_padding_0.$stkvalid
        shift: 11
        buf_req: 11
        next: min_parse_depth_accept_loop.$split_0
      0b**:
        buf_req: 0
        next: end
    min_parse_depth_accept_loop.$split_0:
      match: [ ctr_neg, ctr_zero ]
      option: ignore_max_depth
      0x0:
        counter: dec 11
        0: TB5  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[87:80].80-87
        1..2: TH19  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[79:64].64-79
        3..6: TW7  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[63:32].32-63
        7..10: TW6  # egress::hdr.min_parse_depth_padding_0[1].packet_payload[31:0].0-31
        B16: 4  # value 4 -> B16 bit[3..0]: egress::hdr.min_parse_depth_padding_0.$stkvalid
        shift: 11
        buf_req: 11
        next: min_parse_depth_accept_loop.$it1.$split_0
      0b**:
        buf_req: 0
        next: end
    min_parse_depth_accept_loop.$it1.$split_0:
      match: [ ctr_neg, ctr_zero ]
      option: ignore_max_depth
      0x0:
        counter: dec 11
        0: TB6  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[87:80].80-87
        1..2: TH20  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[79:64].64-79
        3..4: TH9  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[63:48].48-63
        5..6: TH8  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[47:32].32-47
        7..8: TH7  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[31:16].16-31
        B16: 2  # value 2 -> B16 bit[3..0]: egress::hdr.min_parse_depth_padding_0.$stkvalid
        shift: 9
        buf_req: 9
        next: min_parse_depth_accept_loop.$it2.$split_0
      0b**:
        buf_req: 0
        next: end
    min_parse_depth_accept_loop.$it2.$split_0:
      match: [ ctr_neg, ctr_zero ]
      option: ignore_max_depth
      0x0:
        counter: dec 11
        0..1: TH6  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[15:0].0-15
        2: TB7  # egress::hdr.min_parse_depth_padding_0[3].packet_payload[87:80].80-87
        3..4: TH21  # egress::hdr.min_parse_depth_padding_0[3].packet_payload[79:64].64-79
        5..8: TW12  # egress::hdr.min_parse_depth_padding_0[3].packet_payload[63:32].32-63
        9..10: TH11  # egress::hdr.min_parse_depth_padding_0[3].packet_payload[31:16].16-31
        11..12: TH10  # egress::hdr.min_parse_depth_padding_0[3].packet_payload[15:0].0-15
        B16: 1  # value 1 -> B16 bit[3..0]: egress::hdr.min_parse_depth_padding_0.$stkvalid
        shift: 13
        buf_req: 13
        next: end
      0b**:
        0..1: TH6  # egress::hdr.min_parse_depth_padding_0[2].packet_payload[15:0].0-15
        shift: 2
        buf_req: 2
        next: end
deparser egress:
  dictionary:
    TB4: B16(3)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.80-87 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TH18: B16(3)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.64-79 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TW5: B16(3)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.32-63 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TW4: B16(3)  # egress::hdr.min_parse_depth_padding_0[0].packet_payload.0-31 if egress::hdr.min_parse_depth_padding_0[0].$valid
    TB5: B16(2)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.80-87 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TH19: B16(2)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.64-79 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TW7: B16(2)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.32-63 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TW6: B16(2)  # egress::hdr.min_parse_depth_padding_0[1].packet_payload.0-31 if egress::hdr.min_parse_depth_padding_0[1].$valid
    TB6: B16(1)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.80-87 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TH20: B16(1)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.64-79 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TH9: B16(1)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.48-63 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TH8: B16(1)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.32-47 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TH7: B16(1)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.16-31 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TH6: B16(1)  # egress::hdr.min_parse_depth_padding_0[2].packet_payload.0-15 if egress::hdr.min_parse_depth_padding_0[2].$valid
    TB7: B16(0)  # egress::hdr.min_parse_depth_padding_0[3].packet_payload.80-87 if egress::hdr.min_parse_depth_padding_0[3].$valid
    TH21: B16(0)  # egress::hdr.min_parse_depth_padding_0[3].packet_payload.64-79 if egress::hdr.min_parse_depth_padding_0[3].$valid
    TW12: B16(0)  # egress::hdr.min_parse_depth_padding_0[3].packet_payload.32-63 if egress::hdr.min_parse_depth_padding_0[3].$valid
    TH11: B16(0)  # egress::hdr.min_parse_depth_padding_0[3].packet_payload.16-31 if egress::hdr.min_parse_depth_padding_0[3].$valid
    TH10: B16(0)  # egress::hdr.min_parse_depth_padding_0[3].packet_payload.0-15 if egress::hdr.min_parse_depth_padding_0[3].$valid
  egress_unicast_port: H16(0..8)  # bit[8..0]: egress::eg_intr_md.egress_port
stage 0 ingress:
  phase0_match IngressParser.$PORT_METADATA:
    p4:
      name: IngressParser.$PORT_METADATA
      size: 288
      preferred_match_type: exact
      match_type: exact
    size: 288
    p4_param_order:
      ig_intr_md.ingress_port: { type: exact, size: 9 }
    format: {ig_intr_md: 0..63}
    constant_value: 0
    actions:
      set_port_metadata:
      - handle: 0x20000000
      - p4_param_order: { ig_intr_md: 64 } 
  exact_match tcp_classify_0 0:
    p4: { name: Ingress.tcp_classify, size: 4 }
    p4_param_order: 
      hdr.ipv4.$valid: { type: exact, size: 1, full_size: 1 }
      hdr.ipv4.protocol: { type: exact, size: 8, full_size: 8 }
      hdr.tcp.$valid: { type: exact, size: 1, full_size: 1 }
    row: 7
    bus: 1
    column: 3
    stash: 
      row: [ 7 ]
      col: [ 3 ]
      unit: [ 1 ]
    ways:
      - { group: 0, index: 0..9, select: 40..51 & 0x0, rams: [[7, 3]] }
    hash_dist:
      0: { hash: 1, mask: 0xffff, shift: 0 }
    input_xbar:
      exact group 0: { 0: hdr.ipv4.protocol, 9: hdr.ipv4.$valid, 10: hdr.tcp.$valid }
      hash 0:
        0..7: hdr.ipv4.protocol
        8: hdr.ipv4.$valid
        9: hdr.tcp.$valid
      hash group 0:
        table: [0]
        seed: 0x0
      exact group 1: { 0: hdr.tcp.dport, 16: hdr.tcp.sport, 32: hdr.ipv4.dst_addr, 64: hdr.ipv4.src_addr, 96: hdr.ipv4.protocol }
      hash 2:
        0..15: slice(stripe(crc_rev(0xc002, 0x0, 0x0, 104, { 8: hdr.tcp.dport, 24: hdr.tcp.sport, 40: hdr.ipv4.dst_addr }, { })), 0..15)
      hash 3:
        0..15: slice(stripe(crc_rev(0xc002, 0x0, 0x0, 104, { 0: hdr.ipv4.protocol, 72: hdr.ipv4.src_addr }, { })), 0..15)
      hash group 1:
        table: [2, 3]
        seed: 0x0
    format: { action(0): 0..0, version(0): 112..115, action(1): 1..1, version(1): 116..119, action(2): 2..2, version(2): 120..123, action(3): 3..3, version(3): 124..127, action(4): 4..4, version(4): 8..11 }
    match_group_map: [ [ 0, 1, 2, 3, 4 ] ]
    hit: [  classify_https_0 ]
    miss:  classify_https_0
    context_json:
      static_entries:
      - priority: 0
        match_key_fields_values:
        - field_name: hdr.ipv4.$valid
          value: "0x1"
        - field_name: hdr.ipv4.protocol
          value: "0x6"
        - field_name: hdr.tcp.$valid
          value: "0x1"
        action_handle: 0x20000003
        is_default_entry: false
        action_parameters_values: []
      - priority: 1
        match_key_fields_values:
        - field_name: hdr.ipv4.$valid
          value: "0x1"
        - field_name: hdr.ipv4.protocol
          value: "0x6"
        - field_name: hdr.tcp.$valid
          value: "0x0"
        action_handle: 0x20000004
        is_default_entry: false
        action_parameters_values: []
      - priority: 2
        match_key_fields_values:
        - field_name: hdr.ipv4.$valid
          value: "0x1"
        - field_name: hdr.ipv4.protocol
          value: "0x0"
        - field_name: hdr.tcp.$valid
          value: "0x1"
        action_handle: 0x20000004
        is_default_entry: false
        action_parameters_values: []
      - priority: 3
        match_key_fields_values:
        - field_name: hdr.ipv4.$valid
          value: "0x0"
        - field_name: hdr.ipv4.protocol
          value: "0x0"
        - field_name: hdr.tcp.$valid
          value: "0x0"
        action_handle: 0x20000004
        is_default_entry: false
        action_parameters_values: []

    action_bus: { 32..33 : hash_dist(0, lo) }
    instruction: tcp_classify_0(action, $DEFAULT)
    actions:
      Ingress.mark_tcp_and_hash(0, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: false, reason: none }
      - handle: 0x20000003
      - next_table: 0
      - set meta.is_tcp, 1
      - set H4(0..15), hash_dist(0, 0..15)
      Ingress.mark_non_tcp(1, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000004
      - next_table: 0
    default_action: Ingress.mark_non_tcp
  ternary_match classify_https_0 1:
    p4: { name: Ingress.classify_https, size: 3 }
    p4_param_order: 
      hdr.tcp.$valid: { type: exact, size: 1, full_size: 1 }
      hdr.tcp.sport: { type: ternary, size: 16, full_size: 16 }
      hdr.tcp.dport: { type: ternary, size: 16, full_size: 16 }
    row: 0
    bus: 0
    column: 0
    input_xbar:
      ternary group 0: { 0: hdr.tcp.dport, 16: hdr.tcp.sport, 34: hdr.tcp.$valid }
    match:
    - { group: 0, byte_config: 3, dirtcam: 0x155 }
    hit: [  compute_pkt_len_0 ]
    miss:  compute_pkt_len_0
    context_json:
      static_entries:
      - priority: 0
        match_key_fields_values:
        - field_name: hdr.tcp.$valid
          value: "0x1"
        - field_name: hdr.tcp.sport
          value: "0x1BB"
          mask: "0xFFFF"
        - field_name: hdr.tcp.dport
          value: "0x0"
          mask: "0x0"
        action_handle: 0x20000009
        is_default_entry: false
        action_parameters_values: []
      - priority: 1
        match_key_fields_values:
        - field_name: hdr.tcp.$valid
          value: "0x1"
        - field_name: hdr.tcp.sport
          value: "0x0"
          mask: "0x0"
        - field_name: hdr.tcp.dport
          value: "0x1BB"
          mask: "0xFFFF"
        action_handle: 0x20000009
        is_default_entry: false
        action_parameters_values: []

    indirect: classify_https_0$tind
  ternary_indirect classify_https_0$tind:
    row: 0
    bus: 0
    column: 2
    input_xbar:
      ternary group 0: { 0: hdr.tcp.dport, 16: hdr.tcp.sport, 34: hdr.tcp.$valid }
    format: { action: 0..0 }
    instruction: classify_https_0$tind(action, $DEFAULT)
    actions:
      Ingress.set_https_flag(0, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: false, reason: none }
      - handle: 0x20000009
      - next_table: 0
      - set meta.is_https, 1
      Ingress.clear_https_flag(1, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000000a
      - next_table: 0
    default_action: Ingress.clear_https_flag
  exact_match compute_pkt_len_0 2:
    p4: { name: Ingress.compute_pkt_len, size: 2 }
    p4_param_order: 
      hdr.ipv4.$valid: { type: exact, size: 1, full_size: 1 }
    row: 7
    bus: 0
    column: 2
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - { group: 0, index: 10..19, select: 40..51 & 0x0, rams: [[7, 2]] }
    input_xbar:
      exact group 0: { 9: hdr.ipv4.$valid }
      hash 0:
        10: hdr.ipv4.$valid
      hash group 0:
        table: [0]
        seed: 0x0
    format: { action(0): 0..0, immediate(0): 3..18, version(0): 112..115, action(1): 1..1, immediate(1): 19..34, version(1): 116..119, action(2): 2..2, immediate(2): 35..50, version(2): 120..123 }
    match_group_map: [ [ 0, 1, 2 ] ]
    hit: [  forwarding_0 ]
    miss:  forwarding_0
    context_json:
      static_entries:
      - priority: 0
        match_key_fields_values:
        - field_name: hdr.ipv4.$valid
          value: "0x1"
        action_handle: 0x20000001
        is_default_entry: false
        action_parameters_values: []
      - priority: 1
        match_key_fields_values:
        - field_name: hdr.ipv4.$valid
          value: "0x0"
        action_handle: 0x20000002
        is_default_entry: false
        action_parameters_values: []

    action_bus: { 36..37 : immediate(0..15) }
    instruction: compute_pkt_len_0(action, $DEFAULT)
    actions:
      Ingress.set_pkt_len_ipv4(0, 3):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: false, reason: none }
      - handle: 0x20000001
      - next_table: 0
      - { $constant0: immediate(0..15), $constant0: 14 }
      - add H1, $constant0, H0
      Ingress.set_pkt_len_zero(1, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000002
      - next_table: 0
      - {  }
    default_action: Ingress.set_pkt_len_zero
stage 1 ingress:
  dependency: match
  exact_match forwarding_0 0:
    p4: { name: Ingress.forwarding, size: 256 }
    p4_param_order: 
      ig_intr_md.ingress_port: { type: exact, size: 9, full_size: 9 }
    row: 7
    bus: 0
    column: 2
    stash: 
      row: [ 7 ]
      col: [ 2 ]
      unit: [ 0 ]
    ways:
      - { group: 0, index: 0..9, select: 40..51 & 0x0, rams: [[7, 2]] }
    input_xbar:
      exact group 0: { 0: ig_intr_md.ingress_port }
      hash 0:
        0..7: ig_intr_md.ingress_port(0..7)
        8: ig_intr_md.ingress_port(8)
      hash group 0:
        table: [0]
        seed: 0x0
    format: { action(0): 0..0, immediate(0): 5..13, version(0): 112..115, action(1): 1..1, immediate(1): 14..22, version(1): 116..119, action(2): 2..2, immediate(2): 23..31, version(2): 120..123, action(3): 3..3, immediate(3): 32..40, version(3): 124..127, action(4): 4..4, immediate(4): 41..49, version(4): 56..59 }
    match_group_map: [ [ 0, 1, 2, 3, 4 ] ]
    hit: [  https_bytes_update_0 ]
    miss:  https_bytes_update_0
    action_bus: { 32..33 : immediate(0..8) }
    instruction: forwarding_0(action, $DEFAULT)
    actions:
      Ingress.send_using_port(0, 1):
      - p4_param_order: { port: 9 }
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x2000000f
      - next_table: 0
      - { port: immediate(0..8) }
      - set ig_intr_md_for_tm.ucast_egress_port, port
      - set ig_intr_md_for_tm.bypass_egress, 0
      Ingress.drop(1, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true }
      - handle: 0x20000010
      - next_table: 0
      - {  }
      - set ig_intr_md_for_tm.ucast_egress_port, 0
      - set B1(0..3), 249
      NoAction(-1, 0):
      - hit_allowed: { allowed: false, reason: user_indicated_default_only }
      - default_only_action: { allowed: true }
      - handle: 0x20000011
      - next_table: 0
      - {  }
    default_only_action: NoAction
  exact_match https_bytes_update_0 1:
    p4: { name: Ingress.https_bytes_update, size: 2 }
    p4_param_order: 
      meta.is_https: { type: exact, size: 1, full_size: 1 }
    row: 0
    result_bus: 0
    hash_dist:
      0: { hash: 1, mask: 0xffff, shift: 5 }
    input_xbar:
      exact group 0: { 80: meta.flow_idx }
      hash 1:
        0..15: meta.flow_idx
      hash group 1:
        table: [1]
        seed: 0x0
    gateway:
      name: https_bytes_update_0-gateway
      input_xbar:
        exact group 0: { 20: meta.is_https }
      row: 7
      bus: 0
      unit: 0
      payload_row: 0
      payload_unit: 0
      payload: 0xc0001
      format: { action: 0..1, meter_addr: 2..17, meter_pfe: 18..18, meter_type: 19..21 }
      match: { 4: meta.is_https }
      0x1:
        action: do_https_bytes
        next:  https_pkts_update_0
      miss:
        run_table: true
    hit: [  https_pkts_update_0 ]
    miss:  https_pkts_update_0
    stateful: https_bytes_update_0$salu.Ingress.reg_https_flow_bytes(hash_dist 0, meter_pfe, meter_type)
    instruction: https_bytes_update_0(action, $DEFAULT)
    actions:
      Ingress.do_https_bytes(1, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: false, reason: none }
      - handle: 0x2000000d
      - next_table_miss:  https_pkts_update_0
      - next_table: 0
      - https_bytes_update_0$salu.Ingress.reg_https_flow_bytes(https_flow_bytes_add_0, $hash_dist)
      Ingress.nop(2, 3):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000000e
      - next_table_miss:  https_pkts_update_0
      - next_table: 0
    default_action: Ingress.nop
  stateful https_bytes_update_0$salu.Ingress.reg_https_flow_bytes:
    p4: { name: Ingress.reg_https_flow_bytes, size: 65536 }
    row: [ 15, 13, 11 ]
    logical_bus: [ S, O, O ]
    column:
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4 ]
    maprams: 
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4 ]
    home_row: 15
    input_xbar:
      exact group 0: { 64: meta.pkt_len }
    data_bytemask: 3
    format: { lo: 32 }
    actions:
      https_flow_bytes_add_0:
      - add lo, lo, phv_lo(0..15)
  exact_match https_pkts_update_0 2:
    p4: { name: Ingress.https_pkts_update, size: 2 }
    p4_param_order: 
      meta.is_https: { type: exact, size: 1, full_size: 1 }
    row: 0
    result_bus: 1
    hash_dist:
      0: { hash: 1, mask: 0xffff, shift: 5 }
    input_xbar:
      exact group 0: { 80: meta.flow_idx }
      hash 1:
        0..15: meta.flow_idx
      hash group 1:
        table: [1]
        seed: 0x0
    gateway:
      name: https_pkts_update_0-gateway
      input_xbar:
        exact group 0: { 20: meta.is_https }
      row: 0
      bus: 0
      unit: 0
      payload_row: 0
      payload_unit: 1
      payload: 0xc0001
      format: { action: 0..1, meter_addr: 2..17, meter_pfe: 18..18, meter_type: 19..21 }
      match: { 4: meta.is_https }
      0x1:
        action: do_https_pkts
        next:  flow_bytes_update_0
      miss:
        run_table: true
    hit: [  flow_bytes_update_0 ]
    miss:  flow_bytes_update_0
    stateful: https_pkts_update_0$salu.Ingress.reg_https_flow_pkts(hash_dist 0, meter_pfe, meter_type)
    instruction: https_pkts_update_0(action, $DEFAULT)
    actions:
      Ingress.do_https_pkts(1, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: false, reason: none }
      - handle: 0x2000000b
      - next_table_miss:  flow_bytes_update_0
      - next_table: 0
      - https_pkts_update_0$salu.Ingress.reg_https_flow_pkts(https_flow_pkts_add_0, $hash_dist)
      Ingress.nop(2, 4):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x2000000c
      - next_table_miss:  flow_bytes_update_0
      - next_table: 0
    default_action: Ingress.nop
  stateful https_pkts_update_0$salu.Ingress.reg_https_flow_pkts:
    p4: { name: Ingress.reg_https_flow_pkts, size: 65536 }
    row: [ 11, 9, 7, 5 ]
    logical_bus: [ S, O, O, O ]
    column:
    - 5
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3 ]
    maprams: 
    - 5
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3 ]
    home_row: 11
    format: { lo: 32 }
    actions:
      https_flow_pkts_add_0:
      - add lo, lo, 1
stage 2 ingress:
  dependency: match
  exact_match flow_bytes_update_0 0:
    p4: { name: Ingress.flow_bytes_update, size: 2 }
    p4_param_order: 
      meta.is_tcp: { type: exact, size: 1, full_size: 1 }
    row: 0
    result_bus: 0
    hash_dist:
      0: { hash: 0, mask: 0xffff, shift: 5 }
    input_xbar:
      exact group 0: { 8: meta.flow_idx(8..15), 16: meta.flow_idx(0..7) }
      hash 0:
        0..7: meta.flow_idx(0..7)
        8..15: meta.flow_idx(8..15)
      hash group 0:
        table: [0]
        seed: 0x0
    gateway:
      name: flow_bytes_update_0-gateway
      input_xbar:
        exact group 0: { 4: meta.is_tcp }
      row: 0
      bus: 0
      unit: 0
      payload_row: 0
      payload_unit: 0
      payload: 0xc0001
      format: { action: 0..1, meter_addr: 2..17, meter_pfe: 18..18, meter_type: 19..21 }
      match: { 4: meta.is_tcp }
      0x1:
        action: do_flow_bytes
        next:  flow_pkts_update_0
      miss:
        run_table: true
    hit: [  flow_pkts_update_0 ]
    miss:  flow_pkts_update_0
    stateful: flow_bytes_update_0$salu.Ingress.reg_flow_bytes(hash_dist 0, meter_pfe, meter_type)
    instruction: flow_bytes_update_0(action, $DEFAULT)
    actions:
      Ingress.do_flow_bytes(1, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: false, reason: none }
      - handle: 0x20000007
      - next_table_miss:  flow_pkts_update_0
      - next_table: 0
      - flow_bytes_update_0$salu.Ingress.reg_flow_bytes(flow_bytes_add_0, $hash_dist)
      Ingress.nop(2, 1):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000008
      - next_table_miss:  flow_pkts_update_0
      - next_table: 0
    default_action: Ingress.nop
  stateful flow_bytes_update_0$salu.Ingress.reg_flow_bytes:
    p4: { name: Ingress.reg_flow_bytes, size: 65536 }
    row: [ 15, 13, 11 ]
    logical_bus: [ S, O, O ]
    column:
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4 ]
    maprams: 
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4 ]
    home_row: 15
    input_xbar:
      exact group 0: { 64: meta.pkt_len }
    data_bytemask: 3
    format: { lo: 32 }
    actions:
      flow_bytes_add_0:
      - add lo, lo, phv_lo(0..15)
  exact_match flow_pkts_update_0 1:
    p4: { name: Ingress.flow_pkts_update, size: 2 }
    p4_param_order: 
      meta.is_tcp: { type: exact, size: 1, full_size: 1 }
    row: 0
    result_bus: 1
    hash_dist:
      0: { hash: 0, mask: 0xffff, shift: 5 }
    input_xbar:
      exact group 0: { 8: meta.flow_idx(8..15), 16: meta.flow_idx(0..7) }
      hash 0:
        0..7: meta.flow_idx(0..7)
        8..15: meta.flow_idx(8..15)
      hash group 0:
        table: [0]
        seed: 0x0
    gateway:
      name: flow_pkts_update_0-gateway
      input_xbar:
        exact group 0: { 84: meta.is_tcp }
      row: 0
      bus: 1
      unit: 1
      payload_row: 0
      payload_unit: 1
      payload: 0xc0001
      format: { action: 0..1, meter_addr: 2..17, meter_pfe: 18..18, meter_type: 19..21 }
      match: { 4: meta.is_tcp }
      0x1:
        action: do_flow_pkts
        next:  END
      miss:
        run_table: true
    hit: [  END ]
    miss:  END
    stateful: flow_pkts_update_0$salu.Ingress.reg_flow_pkts(hash_dist 0, meter_pfe, meter_type)
    instruction: flow_pkts_update_0(action, $DEFAULT)
    actions:
      Ingress.do_flow_pkts(1, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: false, reason: none }
      - handle: 0x20000005
      - next_table_miss:  END
      - next_table: 0
      - flow_pkts_update_0$salu.Ingress.reg_flow_pkts(flow_pkts_add_0, $hash_dist)
      Ingress.nop(2, 2):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: true, is_constant: true }
      - handle: 0x20000006
      - next_table_miss:  END
      - next_table: 0
    default_action: Ingress.nop
  stateful flow_pkts_update_0$salu.Ingress.reg_flow_pkts:
    p4: { name: Ingress.reg_flow_pkts, size: 65536 }
    row: [ 11, 9, 7, 5 ]
    logical_bus: [ S, O, O, O ]
    column:
    - 5
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3 ]
    maprams: 
    - 5
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3, 4, 5 ]
    - [ 0, 1, 2, 3 ]
    home_row: 11
    format: { lo: 32 }
    actions:
      flow_pkts_add_0:
      - add lo, lo, 1
stage 0 egress:
  ternary_match packet_size_hist_0 3:
    p4: { name: Egress.packet_size_hist, size: 512 }
    p4_param_order: 
      eg_intr_md.pkt_length: { type: range, size: 16, full_size: 16 }
    row: [ 1, 2, 3 ]
    bus: [ 0, 0, 0 ]
    column:
    - 0
    - 0
    - 0
    indirect_bus: 1
    input_xbar:
      ternary group 1: { 0: eg_intr_md.pkt_length, 16: eg_intr_md.pkt_length }
    match:
    - { group: 1, byte_config: 3, dirtcam: 0xfa }
    hit: [  END ]
    miss:  END
    stats: packet_size_hist_0$stats.Egress.packet_size_stats($DIRECT, $DEFAULT)
    instruction: packet_size_hist_0($DEFAULT, $DEFAULT)
    actions:
      Egress.just_count(0, 0):
      - hit_allowed: { allowed: true }
      - default_action: { allowed: false, reason: none }
      - handle: 0x20000012
      - next_table: 0
      - packet_size_hist_0$stats.Egress.packet_size_stats($DIRECT)
      NoAction(-1, 1):
      - hit_allowed: { allowed: false, reason: user_indicated_default_only }
      - default_only_action: { allowed: true, is_constant: true }
      - handle: 0x20000013
      - next_table: 0
    default_only_action: NoAction
  counter packet_size_hist_0$stats.Egress.packet_size_stats:
    p4: { name: Egress.packet_size_stats }
    row: 13
    logical_bus: S
    column: [ 0, 1 ]
    maprams: [ 0, 1 ]
    vpns: [ 0, 1 ]
    home_row: 13
    count: packets
    format: {packets(0): 96..127, packets(1): 64..95, packets(2): 32..63, packets(3): 0..31}
    lrt:
    - { threshold: 23718048, interval: 268435200 }
    - { threshold: 23718048, interval: 268435200 }
    - { threshold: 23718048, interval: 268435200 }


primitives: "basic.prim.json"
dynhash: "basic.dynhash.json"
